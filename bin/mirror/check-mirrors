#!/usr/bin/python -tt

# ProFTPD Mirror Network Maintenance System
# Copyright (c) 2010, John Morrissey <jwm@horde.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.

import datetime
import email.Message
import ftplib
import hashlib
import optparse
import os
import re
import smtplib
import sys
import urllib2
import urlparse

import MySQLdb
import MySQLdb.cursors
import pyme.core
import pyme.pygpgme

import mmaint_creds

# Amount of time after which a site is considered stale.
REACHABLE_STALE_AFTER = datetime.timedelta(days=2)
UNREACHABLE_STALE_AFTER = datetime.timedelta(days=4)

CHECK_SIGNATURES = False
ALLOWED_SIGNATURE_FINGERPRINTS = [
	'697E684D1668D6968428405CB78E893FA511976A', # tj@castaglia.org
]


def get_via_ftp(url):
	parts = urlparse.urlparse(url)

	conn = ftplib.FTP(parts.netloc)
	conn.login()
	data = []
	conn.retrlines('RETR %s' % parts.path,
		lambda s: data.append(s))
	conn.quit()

	return ''.join(data)

def get_via_http(url, host):
	parts = urlparse.urlparse(url)

	req = urllib2.Request(url, headers={
		'Host': parts.netloc,
		'Accept': '*/*',
		'User-Agent': os.path.basename(sys.argv[0]),
	})
	return urllib2.urlopen(req).read()

def check_signatures(parsed):
	conn = ftplib.FTP(parsed.netloc)
	conn.login()

	files = conn.nlst(urlparse.urljoin(parsed.path,
		'distrib/source'))
	tarballs = [
		file
		for file
		 in files
		 if file.endswith('.tar.gz') or
		    file.endswith('.tar.bz2')
	]
	for file in tarballs:
		if '%s.md5' % file not in files:
			print >>sys.stderr, \
				'MD5 signature %s doesn\'t exist for %s.' % (
					'%s.md5' % file, file,
				)
			continue
		if '%s.asc' % file not in files:
			print >>sys.stderr, \
				'PGP signature %s doesn\'t exist for %s.' % (
					'%s.asc' % file, file,
				)
			continue

		data = []
		conn.retrbinary('RETR %s' % file,
			lambda chunk: data.append(chunk))
		data = ''.join(data)

		md5_sig = []
		conn.retrlines('RETR %s.md5' % file,
			lambda line: md5_sig.append(line))
		md5_sig = '\n'.join(md5_sig)
		md5_sig = md5_sig.split()[0]

		pgp_sig = []
		conn.retrlines('RETR %s.asc' % file,
			lambda line: pgp_sig.append(line))
		pgp_sig = '\n'.join(pgp_sig)

		m = hashlib.md5(data)
		if md5_sig != m.hexdigest():
			print 'Invalid MD5 signature for %s on %s' % (
				file, row['site'],
			)

		c = pyme.core.Context()
		c.op_verify(pyme.core.Data(string=pgp_sig),
			pyme.core.Data(string=data), None)
		result = c.op_verify_result()

		for sign in result.signatures:
			if (sign.summary & pyme.pygpgme.GPGME_SIGSUM_VALID) and \
			   sign.fpr in ALLOWED_SIGNATURE_FINGERPRINTS:
				break
		else:
			print 'Invalid signature for %s on %s' % (
				file, row['site'],
			)

	conn.quit()

def notify_stale_mirror(info):
	msg = email.Message.Message()
	msg['From'] = 'core@proftpd.org'
	msg['Cc'] = 'ProFTPD Core Team <core@proftpd.org>'
	msg['To'] = 'To: %s <%s>' % (
		info['admin'], info['admin_email'],
	)
	msg['Subject'] = 'proftpd.org mirror update'

	msg.set_payload("""
%(admin)s,

This is a automatic e-mail to inform you that your mirror of:

    %(scheme)s://%(canon_site_hostname)s.proftpd.org/

does not appear to be functioning properly. The URL that failed was:

    %(failed_url)s
    Error: %(error)s
    Last update pulled on: %(last_updated)s

The details we have on record for your mirror are:

    Site:        %(site)s
    Admin:       %(admin)s
    Admin_email: %(admin_email)s
    Site Info:   %(other_details)s
    Location:    %(city)s/%(country_iso)s

Your mirror should be accepting connections for the following sites

    %(scheme)s://%(canon_site_hostname)s.%(country_iso)s.proftpd.org/
    %(scheme)s://%(canon_site_hostname)s%(sequence)s.%(country_iso)s.proftpd.org/

We have temporarily removed your site from the proftpd.org DNS. Please let
us know when things are back to normal or if you wish to cease being a
mirror site, and we will update our records accordingly.

Thanks,
The ProFTPD Core Team
""" % info)

	to_addrs = msg.get_all('To') + msg.get_all('Cc')

	s = smtplib.SMTP()
	s.connect()
	s.sendmail(msg['From'], ', '.join(to_addrs), msg.as_string())
	s.quit()


parser = optparse.OptionParser()
parser.add_option('-m', '--match', dest='match', default=[],
	action='append',
	help='check whether mirror sites containing SUBSTRING are up to date',
	metavar='SUBSTRING')
parser.add_option('-N', '--nonotify', dest='notify_stale', default=True,
	action='store_false', help='don\'t notify stale mirrors')
parser.add_option('-t', '--type', dest='type', default=[],
	action='append', help='type of mirrors to check', metavar='ftp|www')
parser.add_option('-v', '--verbose', dest='verbose', default=False,
	action='store_true',
	help='emit status output for each mirror, regardless of whether it\'s up to date')

(options, args) = parser.parse_args()

if len(args) > 0:
	parser.print_help()
	sys.exit(1)

if not options.type:
	options.type = ['ftp', 'www']
for type in options.type:
	if type not in ['ftp', 'www']:
		print >>sys.stderr, 'Invalid type: "%s"' % type
		parser.print_help()
		sys.exit(1)


db = MySQLdb.connect(host=mmaint_creds.DB['host'],
	user=mmaint_creds.DB['user'], passwd=mmaint_creds.DB['pass'],
	db=mmaint_creds.DB['db'], cursorclass=MySQLdb.cursors.DictCursor)
c = db.cursor()

now = datetime.datetime.now()

if CHECK_SIGNATURES:
	if options.verbose:
		print 'Checking tarball signatures on ftp.proftpd.org...'
	check_signatures(urlparse.urlparse('ftp://ftp.proftpd.org/'))

for type in options.type:
	query = """
	    SELECT *
	      FROM %smirrors LEFT JOIN countrycode ON
	           %smirrors.country_iso = countrycode.iso
	     WHERE live = 'true'
	""" % (type, type)

	if options.match:
		query += ' AND ('
		query += ' OR '.join([
			'site LIKE \'%%%s%%\'' % match
			for match in options.match
		])
		query += ') '

	query += """
	  ORDER BY iso, sequence
	"""

	c.execute(query)

	for row in c.fetchall():
		parse_site = row['site']
		if not parse_site.endswith('/'):
			parse_site += '/'

		site_parsed = urlparse.urlparse(parse_site)

		to_check = [
			parse_site
		]
		if type == 'www':
			to_check.append('http://www%s.%s.proftpd.org/' % (
				row['sequence'], row['iso']
			))
			to_check.append('http://www.%s.proftpd.org/' % \
				row['iso'])

		if type == 'ftp' and CHECK_SIGNATURES:
			if options.verbose:
				print 'Checking tarball signatures on %s...' % row['site']

			check_signatures(site_parsed)

		for url in to_check:
			stale = False
			error = None
			tstamp = None
			last_pull = None
			try:
				p = urlparse.urlparse(url)
				mirmon_url = urlparse.urlunparse((p.scheme,
					site_parsed.netloc,
					urlparse.urljoin(p.path, 'MIRMON.PROBE'),
					p.params, p.query, p.fragment))

				if url.startswith('ftp://'):
					canon_site_hostname = 'ftp'
					tstamp = int(get_via_ftp(mirmon_url))
					last_pull = datetime.datetime.fromtimestamp(tstamp)
				elif url.startswith('http://'):
					canon_site_hostname = 'www'
					tstamp = int(get_via_http(mirmon_url,
						site_parsed.hostname))
					last_pull = datetime.datetime.fromtimestamp(tstamp)

				if last_pull + REACHABLE_STALE_AFTER < now:
					stale = True
			except Exception, e:
				if url == row['site']:
					print >>sys.stderr, \
						'Unable to check site %s: %s' % (
							row['site'], str(e),
						)
				else:
					print >>sys.stderr, \
						'Unable to check URL %s for site %s: %s' % (
							url, row['site'], str(e),
						)
				error = str(e)

				last_pull = row['last_pull']
				if not last_pull or \
				   last_pull + UNREACHABLE_STALE_AFTER < now:
					stale = True

			# Only update the stored last_pull date if we have a
			# fresh timestamp from the mirror.
			if tstamp:
				query = """
					UPDATE %smirrors
					   SET last_pull = %%s
					 WHERE site = %%s
				""" % type
				c.execute(query, [
					last_pull.strftime('%Y-%m-%d %H:%M:%S'),
					row['site'],
				])

			if options.verbose:
                # startswith() to account for the trailing
                # slash we might have added to url.
				if url.startswith(row['site']):
					print '%s last updated at %s (%s)' % (
						row['site'], last_pull, tstamp,
					)
				else:
					print '%s (%s) last updated at %s (%s)' % (
						url, site_parsed.netloc, last_pull, tstamp,
					)

			if stale:
				if not error:
					error = 'Not updated within last %s.' % \
						REACHABLE_STALE_AFTER
				print '%s is out of date: %s (%s)' % (
					row['site'], last_pull, tstamp,
				)

			if stale and options.notify_stale:
				print 'Sending notification for stale mirror %s...' % \
					row['site']

				info = row.copy()
				info.update({
					'canon_site_hostname': canon_site_hostname,
					'error': error,
					'failed_url': url,
					'last_updated':
						last_pull.strftime('%Y-%b-%d %H:%M:%S'),
					'scheme': site_parsed.scheme,
				})
				notify_stale_mirror(info)

				# Don't check other URLs for this mirror;
				# they'll just generate duplicate notifications.
				break
