#!/usr/bin/python -tt

# ProFTPD Mirror Network Maintenance System
# Copyright (c) 2010, John Morrissey <jwm@horde.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.

# Number of seconds after which a site is considered stale.
STALE_AFTER = 2 * 24 * 60 * 60

ALLOWED_SIGNATURE_FINGERPRINTS = [
	'697E684D1668D6968428405CB78E893FA511976A', # tj@castaglia.org
]

import email.Message
import ftplib
import hashlib
import optparse
import re
import smtplib
import sys
import time
import urllib2
import urlparse

import MySQLdb
import MySQLdb.cursors
import pyme.core
import pyme.pygpgme

def get_via_ftp(url):
	parts = urlparse.urlparse(url)

	conn = ftplib.FTP(parts.netloc)
	conn.login()
	data = []
	conn.retrlines('RETR %s' % parts.path,
		lambda s: data.append(s))
	conn.quit()

	return ''.join(data)

def get_via_http(url, host):
	parts = urlparse.urlparse(url)

	req = urllib2.Request(url, headers={'Host': parts.netloc})
	return urllib2.urlopen(req).read()

def check_signatures(parsed):
	conn = ftplib.FTP(parsed.netloc)
	conn.login()

	files = conn.nlst(urlparse.urljoin(parsed.path,
		'distrib/source'))
	tarballs = [
		file
		for file
		 in files
		 if file.endswith('.tar.gz') or
		    file.endswith('.tar.bz2')
	]
	for file in tarballs:
		if '%s.md5' % file not in files:
			print >>sys.stderr, \
				'MD5 signature %s doesn\'t exist for %s.' % (
					'%s.md5' % file, file,
				)
			continue
		if '%s.asc' % file not in files:
			print >>sys.stderr, \
				'PGP signature %s doesn\'t exist for %s.' % (
					'%s.asc' % file, file,
				)
			continue

		data = []
		conn.retrbinary('RETR %s' % file,
			lambda chunk: data.append(chunk))
		data = ''.join(data)

		md5_sig = []
		conn.retrlines('RETR %s.md5' % file,
			lambda line: md5_sig.append(line))
		md5_sig = '\n'.join(md5_sig)
		md5_sig = md5_sig.split()[0]

		pgp_sig = []
		conn.retrlines('RETR %s.asc' % file,
			lambda line: pgp_sig.append(line))
		pgp_sig = '\n'.join(pgp_sig)

		m = hashlib.md5(data)
		if md5_sig != m.hexdigest():
			print 'Invalid MD5 signature for %s on %s' % (
				file, row['site'],
			)

		c = pyme.core.Context()
		c.op_verify(pyme.core.Data(string=pgp_sig),
			pyme.core.Data(string=data), None)
		result = c.op_verify_result()

		for sign in result.signatures:
			# FIXME: sign.status is always GPGME_VALIDITY_UNKNOWN
			# instead of GPGME_SIGSUM_VALID, even though AFAICT
			# the signing key is trusted and the signature valid.
			if sign.status != pyme.pygpgme.GPGME_SIGSUM_VALID:
				continue
			if sign.fpr in ALLOWED_SIGNATURE_FINGERPRINTS:
				break
		else:
			print 'Invalid signature for %s on %s' % (
				file, row['site'],
			)

	conn.quit()

def notify_stale_mirror(info):
	msg = email.Message.Message()
	msg['From'] = 'core@proftpd.org'
	msg['Cc'] = 'core@proftpd.org'
	msg['To'] = 'To: %s <%s>' % (
		info['admin'], info['admin_email'],
	)
	msg['Subject'] = 'proftpd.org mirror update'

	msg.set_payload("""
%(admin)s,

This is a semi-automatic email to inform you that your mirror of

	%(scheme)s://%(canon_site_hostname)s.proftpd.org/

does not appear to be functioning properly.

The details we have on record for your mirror are:

	Site:	     %(site)s
	Admin:       %(admin)s
	Admin_email: %(admin_email)s
	Site Info:   %(other_details)s
	Updated:     %(last_updated)s
	Location:    %(city)s/%(country_iso)s

Your mirror should be accepting connections for the following sites

	%(scheme)s://%(canon_site_hostname)s.%(country_iso)s.proftpd.org/
	%(scheme)s://%(canon_site_hostname)s%(sequence)s.%(country_iso)s.proftpd.org/

We have temporarily removed your site from the proftpd.org DNS. Please let
us know when things are back to normal or if you wish to cease being a
mirror site, and we will update our records accordingly.

Thanks,
The ProFTPD Core Team
""" % info)

	s = smtplib.SMTP()
	s.connect()
	s.sendmail(msg['From'], msg['To'], msg.as_string())
	s.quit()


parser = optparse.OptionParser()
parser.add_option('-m', '--match', dest='match', default=[],
	action='append',
	help='check whether mirror sites containing SUBSTRING are up to date',
	metavar='SUBSTRING')
parser.add_option('-N', '--nonotify', dest='notify_stale', default=True,
	action='store_false', help='don\'t notify stale mirrors')
parser.add_option('-t', '--type', dest='type', default=[],
	action='append', help='type of mirrors to check', metavar='ftp|www')
parser.add_option('-v', '--verbose', dest='verbose', default=False,
	action='store_true',
	help='emit status output for each mirror, regardless of whether it\'s up to date')

(options, args) = parser.parse_args()

if len(args) > 0:
	parser.print_help()
	sys.exit(1)

if not options.type:
	options.type = ['ftp', 'www']
for type in options.type:
	if type not in ['ftp', 'www']:
		print >>sys.stderr, 'Invalid type: "%s"' % type
		parser.print_help()
		sys.exit(1)


db = MySQLdb.connect(host='localhost', user='', passwd='',
	db='proftpd', cursorclass=MySQLdb.cursors.DictCursor)
c = db.cursor()

for type in options.type:
	query = """
	    SELECT *
	      FROM %smirrors LEFT JOIN countrycode ON
	           %smirrors.country_iso = countrycode.iso
	     WHERE live = 'true'
	""" % (type, type)

	if options.match:
		query += ' AND ('
		query += ' OR '.join([
			'site LIKE \'%%%s%%\'' % match
			for match in options.match
		])
		query += ') '

	query += """
	  GROUP BY country_iso
	  ORDER BY iso, sequence
	"""

	c.execute(query)

	for row in c.fetchall():
		if type == 'ftp':
			to_check = [
				row['site'],
			]
		elif type == 'www':
			to_check = [
				row['site'],
				'http://www%s.%s.proftpd.org/' % (row['sequence'], row['iso']),
				'http://www.%s.proftpd.org/' % row['iso'],
			]

		host_parts = urlparse.urlparse(row['site'])

		if type == 'ftp':
			if options.verbose:
				print 'Checking tarball signatures on %s...' % row['site']

			check_signatures(host_parts)

		for url in to_check:
			stale = False
			try:
				p = urlparse.urlparse(url)
				mirmon_url = urlparse.urlunparse((p.scheme,
					host_parts.netloc,
					urlparse.urljoin(p.path, 'MIRMON.PROBE'),
					p.params, p.query, p.fragment))

				if url.startswith('ftp://'):
					canon_site_hostname = 'ftp'
					tstamp = int(get_via_ftp(mirmon_url))
				elif url.startswith('http://'):
					canon_site_hostname = 'www'
					tstamp = int(get_via_http(mirmon_url,
						host_parts.hostname))

				if tstamp + STALE_AFTER < time.time():
					stale = True
			except Exception, e:
				print >>sys.stderr, \
					'Unable to check URL %s for site %s' % (
						url, row['site'],
					)
				stale = True

			if stale or options.verbose:
				print '%s is out of date: %s (%s)' % (
					row['site'], tstamp,
					time.strftime('%Y-%b-%d %H:%M:%S',
						time.localtime(tstamp)),
				)

			if stale and options.notify_stale:
				info = row.copy()
				info.update({
					'scheme': host_parts.scheme,
					'canon_site_hostname': canon_site_hostname,
					'last_updated': time.strftime('%Y-%b-%d %H:%M:%S',
						time.localtime(tstamp)),
				})
				notify_stale_mirror(info)
